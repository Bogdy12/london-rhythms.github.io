<!DOCTYPE html>
<meta charset="utf-8">
<style>
form {
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  position: absolute;
  left: 10px;
  top: 10px;
}
label {
  display: block;
}
</style>
<form>
  <label><input type="radio" name="mode" value="line"> Line</label>
  <label><input type="radio" name="mode" value="stacked" checked> Stacked</label>
</form>
<svg width="960" height="500"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>
/*
var n = 4, // The number of series.
    m = 58; // The number of values per series.
// The xz array has m elements, representing the x-values shared by all series.
// The yz array has n elements, representing the y-values of each of the n series.
// Each yz[i] is an array of m non-negative numbers representing a y-value for xz[i].
// The y01z array has the same structure as yz, but with stacked [y₀, y₁] instead of y.
var xz = d3.range(m),
    yz = d3.range(n).map(function() { return bumps(m); }),  //bumps:custom function,see below
    y01z = d3.stack().keys(d3.range(n))(d3.transpose(yz)),  
    yMax = d3.max(yz, function(y) { return d3.max(y); }),
    y1Max = d3.max(y01z, function(y) { return d3.max(y, function(d) { return d[1]; }); });
*/

// create canvas
var svg = d3.select("svg"),
    margin = {top: 40, right: 10, bottom: 20, left: 10},
    width = +svg.attr("width") - margin.left - margin.right,
    height = +svg.attr("height") - margin.top - margin.bottom,
    g = svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");

// import data
d3.csv("yelp_hours.csv",function(error,dataset){
	var pubs = [];
	var musicvenues = [];
	var restaurants = [];
	var time = [];
	
	//var parseTime = d3.timeParse("%H:%M:%S");
	for(var i=0;i<24;i++){
		pubs.push(parseFloat(dataset[i].pubs));
		musicvenues.push(parseFloat(dataset[i].musicvenues));
		restaurants.push(parseFloat(dataset[i].restaurants));
		time.push(dataset[i].time.slice(0,-3));
	}
	var yz = [pubs,musicvenues,restaurants];
	var yzStack = d3.stack().keys(time)(yz);
	var yzMax = d3.max(yz,function(y){return d3.max(y);});
	var yzSMax = d3.max(yzStack, function(y){return d3.max(y,function(d){return d[1];});});

	// scales of x and y
	var x = d3.scaleBand()
	    .domain(time)  //this shows at x axis
	    .rangeRound([0, width])
	    .padding(0.08);
	var y = d3.scaleLinear()
	    .domain([0, yzSMax])
	    .range([height, 0]);
	var color = d3.scaleOrdinal()
	    .domain(d3.range(yz.length))
	    .range(d3.schemeCategory10);

	// create group elements 
	var series = g.selectAll(".series")
	  .data(yzStack)
	  .enter().append("g")
	    .attr("fill", function(d, i) { return color(i); });

	// draw rect based on series
	var rect = series.selectAll("rect")
	  .data(function(d) { return d; })
	  .enter().append("rect")
	    .attr("x", function(d, i) { return i; })
	    .attr("y", height)
	    .attr("width", x.bandwidth())
	    .attr("height", 0);
	rect.transition()
	    .delay(function(d, i) { return i * 10; })
	    .attr("y", function(d) { return y(d[1]); })
	    .attr("height", function(d) { return y(d[0]) - y(d[1]); });
	g.append("g")
	    .attr("class", "axis axis--x")
	    .attr("transform", "translate(0," + height + ")")
	    .call(d3.axisBottom(x)
	        .tickSize(0)
	        .tickPadding(6));
	d3.selectAll("input")
	    .on("change", changed); //add a change listener to the input

	// timer stops automatically
	var timeout = d3.timeout(function() {
	  d3.select("input[value=\"line\"]")
	      .property("checked", true)  //if the value input is true
	      .dispatch("change"); //dispatch a custom event
	}, 2000);

	function changed() {
	  timeout.stop();
	  if (this.value === "line") transitionLine();
	  else transitionStacked();
	}

	function transitionLine() {
	  y.domain([0, yzMax]); //change the domain of y
	  rect.transition()
	      .duration(500)
	      .delay(function(d, i) { return i * 10; })
	      .attr("x", function(d, i) { return x(i) + x.bandwidth() / yz.length * this.parentNode.__data__.key; })
	      .attr("width", x.bandwidth() / yz.length)
	    .transition()
	      .attr("y", function(d) { return y(d[1] - d[0]); })
	      .attr("height", function(d) { return y(0) - y(d[1] - d[0]); });
	}

	function transitionStacked() {
	  y.domain([0, yzSMax]);
	  rect.transition()
	      .duration(500)
	      .delay(function(d, i) { return i * 10; })
	      .attr("y", function(d) { return y(d[1]); })
	      .attr("height", function(d) { return y(d[0]) - y(d[1]); })
	    .transition()
	      .attr("x", function(d, i) { return x(i); })
	      .attr("width", x.bandwidth());
	}
});
</script>